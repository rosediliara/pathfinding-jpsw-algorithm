#ifndef XYTHETA_LATTICE_GRAPH_H
#define XYTHETA_LATTICE_GRAPH_H

#include <vector>
#include <string>
#include <sstream>
#include <stdint.h>
#include <limits>

#include "../../Utils/range.h"
#include "GraphDefinitions.h"
#include "GraphConnectedComponentAnalyzer.h"
#include "Lattice.h"

// Implements a lattice graph by allowing operations with nodeIds.
// NodeIds are generated by linearizing the 3D (x,y,theta) grid.
// This linearization does not consider the padding of the underlying grid.
//
// The graph stores the edges semi-implicitly:
// It stores a 32-bit integer for each node (assuming the number of primitives
// for each pose is no more than 32), where the kth bit specifies whether
// the kth primitive for the pose can be executed without collisions.
// This implementation has a nice runtime/memory trade-off:
//   - We don't have to store explicit neighbors and their distances.
//     (64-bits per edge vs 32 bits per nodeId.)
//   - We don't need to do collision checking.
//     (Which requires iterating over the swept-cells of all the primitives.)

// HACK: We assume the number of discrete poses is a power of 2.
// This allows us to allocate a certain number of bits to specify the pose
// during linearization, which might speed-up conversions between nodeId and
// state.
// If this assumption doesn't hold, then we basically create more nodes than
// necessary. These are invalid nodes, but still take up space when we use
// data structures that preallocate memory for nodes.


// TODO: Manage the primitive flags in a smarter way so that we don't
// allocate extra memory.

class LatticeGraph {
 public:
  typedef WeightedArcHead SuccessorType;

  LatticeGraph(Lattice* lattice = NULL);
  ~LatticeGraph();

  bool IsUndirected() const {
    return is_undirected_;
  }
  unsigned int GetNumAllNodes() const {
    return num_linearized_nodes_;
  }
  // Used only for statistics.
  int GetNumValidNodes() const {
    return num_valid_nodes_;
  }
  int GetNumArcs() const {
    return num_valid_edges_;
  }

  Lattice* GetLattice() {
    return xyt_l_;
  }

  // FIXME
  bool HasNoSuccessors(nodeId n) {
    return false;
  }

  void GetSuccessors(nodeId n, std::vector<WeightedArcHead> & neighbors,
                     ExecutablePrimitiveFlags prim_mask = -1) const;
  void GetPredecessors(nodeId n, std::vector<WeightedArcHead> & neighbors,
                       ExecutablePrimitiveFlags prim_mask = -1) const;

  ExecutablePrimitiveFlags GetForwardExecutablePrimitiveFlags(nodeId n) const {
    return valid_forward_primitive_flags_[n];
  }
  ExecutablePrimitiveFlags GetReverseExecutablePrimitiveFlags(nodeId n) const {
    if (is_undirected_)
      return valid_forward_primitive_flags_[n];
    else
      return valid_reverse_primitive_flags_[n];
  }


  std::string GetNodeName(nodeId n) const;
  nodeId GetNodeIdFromName(std::string s) const;

  bool IsValidNode(nodeId n) {
    return valid_node_[n];
  }

  nodeId ToNodeId(xyThetaPos pos) const {
    return ((height_ * pos.x + pos.y) << num_angle_bits_) | pos.o;
  }
  xyThetaPos ToState(nodeId id) const {
    xyThetaPos p;
    p.o = id & angle_mask_;
    id = id >> num_angle_bits_;
    p.x = id / height_;
    p.y = id - (p.x * height_);
    return p;
  }


#ifndef NO_HOG
  // TODO: Priorities don't mean anything at the moment.
  void DrawDirectedNode(const MapEnvironment *env, xyThetaPos p, double length =
                            0.4) const;
  void DrawArrowNode(const MapEnvironment *env, xyThetaPos p,
                     double ratio = 1.0, int priority = 5) const;

  void DrawNode(const MapEnvironment *env, xyThetaPos p, double priority = 0) const;
  void DrawEdge(const MapEnvironment *env, xyThetaPos from, xyThetaPos to,
                double width = kDrawEdgeWidth) const;

  void DrawNode(const MapEnvironment *env, nodeId n,
                double priority = 0) const {
    return DrawNode(env, ToState(n), priority);
  }
  void DrawEdge(const MapEnvironment *env, nodeId from, nodeId to,
                double width = 1) const {
    return DrawEdge(env, ToState(from), ToState(to), width);
  }

  void DrawArrowNode(const MapEnvironment *env, nodeId n,
                     double ratio = 1.0, int priority = 5) const {
    return DrawArrowNode(env, ToState(n), ratio, priority);
  }

  void DrawPath(const MapEnvironment *env,
                const std::vector<nodeId> & path) const;
  void VisualizeExecutablePrimitives(const MapEnvironment *env, xyThetaPos pos,
                                bool show_predecessors_instead = false) const;
  void SetVisualizeNodeDirection(bool show_direction) const {
    show_direction_ = show_direction;
  }
#endif

  void GetSuccessors(nodeId n, WeightedArcHead* & neighbors, int & num_neighbors) {
    GetSuccessors(n, temp_neighbors_);
    neighbors = &temp_neighbors_[0];
    num_neighbors = temp_neighbors_.size();
  }
  Range<typename std::vector<WeightedArcHead>::iterator> GetSuccessors (nodeId n) {
    GetSuccessors(n, temp_neighbors_);
    return vector_to_reference_range(temp_neighbors_);
  }
  Range<typename std::vector<WeightedArcHead>::iterator> GetPredecessors (nodeId n) {
    GetPredecessors(n, temp_neighbors_);
    return vector_to_reference_range(temp_neighbors_);
  }
  Distance GetWeight(nodeId n, WeightedArcHead & h) {
    return h.weight;
  }


  // FIXME: Doesn't seem to be necessary. Can also be implemented faster using
  // masks.
  bool HasMissingSuccessor(nodeId n) {
    xyThetaPos p = ToState(n);
    std::vector<const MotionPrimitive*> prims;
    xyt_l_->GetExecutableForwardPrimitives(p, prims);
    return xyt_l_->GetAllForwardPrimitives(p.o)->size()
        == prims.size();
  }
  bool HasMissingPredecessor(nodeId n) {
    xyThetaPos p = ToState(n);
    std::vector<const MotionPrimitive*> prims;
    xyt_l_->GetExecutableReversePrimitives(p, prims);
    return xyt_l_->GetAllReversePrimitives(p.o)->size()
        == prims.size();
  }

  Distance GetEdgeLength(xyThetaPos p1, xyThetaPos p2) {
    const MotionPrimitive* prim = xyt_l_->GetIntermediatePrimitive(p1,p2);
    if (prim == NULL)
      return kMaxDistance;
    else
      return prim->GetCost();
  }

 private:
  std::vector<WeightedArcHead> temp_neighbors_;

  Grid2D* grid_;
  Lattice* xyt_l_;

  int width_, height_, num_angles_;
  unsigned int num_linearized_nodes_, num_valid_nodes_, num_valid_edges_;

  bool is_undirected_;

  int num_angle_bits_;
  nodeId angle_mask_;

  std::vector<bool> valid_node_;

  void IdentifyValidNodes();
  void GenerateNeighbors();
  void IdentifyLargestConnectedComponent();

  std::vector<ExecutablePrimitiveFlags> valid_forward_primitive_flags_;
  std::vector<ExecutablePrimitiveFlags> valid_reverse_primitive_flags_;

  // When drawing a node, instead of drawing a sphere for the grid cell,
  // draw a line originating from its center,
  // extending to the direction that the orientation is pointing at.
  mutable bool show_direction_;

  // Given a node, generate flags to identify executable primitives.
  ExecutablePrimitiveFlags GenerateExecutablePrimitiveFlags(nodeId n, bool forward);
  void GetNeighbors(nodeId n, ExecutablePrimitiveFlags flags,
                    std::vector<MotionPrimitive>* prims,
                    std::vector<WeightedArcHead> & neighbors) const;

  void Debug();
};

#endif
